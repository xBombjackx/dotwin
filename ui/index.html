<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Vectorizer</title>
    <!-- Using Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ADDING IMAGETRACER.JS LIBRARY -->
    <script src="https://cdn.jsdelivr.net/gh/jankovicsandras/imagetracerjs@master/imagetracer_v1.2.6.js"></script>
    <style>
        /* A little custom style for the file input to hide it cleanly */
        .file-input {
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }
        /* Style for the dropzone when a file is being dragged over it */
        .dragover {
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }
    </style>
</head>
<body class="bg-slate-100 font-sans flex items-center justify-center min-h-screen">

    <div class="bg-white rounded-xl shadow-lg p-8 w-full max-w-lg mx-4">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-slate-800">Image Vectorizer</h1>
            <p class="text-slate-500 mt-1">Drop an image to convert it into a layered SVG.</p>
        </header>

        <main>
            <!-- 1. Image Drop Zone -->
            <div id="drop-zone" class="border-2 border-dashed border-slate-300 rounded-lg p-10 text-center cursor-pointer transition-all duration-300 ease-in-out hover:border-blue-500 hover:bg-blue-50">
                <input type="file" id="file-input" class="file-input" accept="image/png, image/jpeg, image/gif">
                <label for="file-input" class="cursor-pointer">
                    <svg class="mx-auto h-12 w-12 text-slate-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true">
                        <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                    </svg>
                    <p class="mt-2 text-slate-600">
                        <span class="font-semibold">Click to upload</span> or drag & drop an image here.
                    </p>
                    <p class="text-xs text-slate-500 mt-1">PNG, JPG, GIF up to 10MB</p>
                </label>
            </div>

            <!-- 2. Status and Preview Area -->
            <div id="status-area" class="mt-6 text-center hidden">
                <div id="preview-container" class="w-32 h-32 mx-auto rounded-md overflow-hidden bg-slate-200 flex items-center justify-center">
                     <img id="preview-image" src="" alt="Image preview" class="w-full h-full object-cover">
                </div>
                <p id="status-message" class="text-slate-600 mt-2 text-sm">Processing...</p>
            </div>

             <!-- Color Configuration -->
            <div id="config-area" class="mt-6 hidden">
                <label for="color-slider" class="block text-sm font-medium text-slate-700">Number of Colors: <span id="color-count" class="font-bold">16</span></label>
                <input id="color-slider" type="range" min="2" max="32" value="16" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer mt-1">
            </div>

            <!-- 3. "Save SVG" Button -->
            <div class="mt-8">
                <button id="save-button" class="w-full bg-blue-500 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 ease-in-out disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                    Save SVG
                </button>
            </div>
        </main>

    </div>

    <!-- This is where the application logic will go, as per Section 3.2 -->
    <script>
        // DOM Element References
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const statusArea = document.getElementById('status-area');
        const previewImage = document.getElementById('preview-image');
        const statusMessage = document.getElementById('status-message');
        const configArea = document.getElementById('config-area');
        const colorSlider = document.getElementById('color-slider');
        const colorCount = document.getElementById('color-count');
        const saveButton = document.getElementById('save-button');

        // Application State
        let vectorizedData = null;
        let originalFile = null;
        let imageObject = null; // To hold the loaded Image object

        // --- Event Listeners ---

        // Handle clicks on the drop zone to trigger the hidden file input
        dropZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Drag and Drop Listeners
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault(); // Necessary to allow drop
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        // Slider listener
        colorSlider.addEventListener('input', (e) => {
            colorCount.textContent = e.target.value;
            // If an image is already loaded, re-vectorize with new color count
            if(imageObject) {
                processImage();
            }
        });
        
        // Save button listener
        saveButton.addEventListener('click', () => {
            if (vectorizedData) {
                // This is where we will call the Rust backend via a Tauri command
                // as described in Section 3.3 of the technical guide.
                console.log("Preparing to save SVG...");
                
                const svgString = assembleSvgString(vectorizedData);
                console.log("Generated SVG:", svgString);

                // For now, we'll trigger a browser download as a placeholder
                // This will be replaced by the Tauri dialog API call.
                const blob = new Blob([svgString], {type: 'image/svg+xml'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'vectorized-image.svg';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });


        // --- Core Logic Functions ---

        /**
         * Handles the file once it's selected or dropped.
         */
        function handleFile(file) {
            console.log('File selected:', file.name);
            originalFile = file;

            const reader = new FileReader();
            reader.onload = (e) => {
                // Show a preview
                previewImage.src = e.target.result;
                statusArea.classList.remove('hidden');
                configArea.classList.remove('hidden');
                
                // Create an Image object to get dimensions and draw to canvas
                imageObject = new Image();
                imageObject.onload = () => {
                    // Now that the image is fully loaded, process it
                    processImage();
                };
                imageObject.src = e.target.result;
            };
            reader.readAsDataURL(file);
            
            // Reset state
            saveButton.disabled = true;
            vectorizedData = null;
        }

        /**
         * Processes the image using ImageTracer.js.
         * This is Step 3.2.1 and 3.2.2 in the guide.
         */
        function processImage() {
            if (!imageObject) return;

            statusMessage.textContent = "Vectorizing image...";
            saveButton.disabled = true;
            
            // Using a timeout to allow the UI to update before the potentially blocking tracing operation
            setTimeout(() => {
                // 1. Create an off-screen <canvas>.
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = imageObject.width;
                canvas.height = imageObject.height;

                // 2. Draw the loaded image onto the canvas.
                ctx.drawImage(imageObject, 0, 0);

                // 3. Get the ImageData from the canvas.
                const imageData = ctx.getImageData(0, 0, imageObject.width, imageObject.height);

                // 4. Call ImageTracer.imagedataToTracedata() with options.
                const options = {
                    numberofcolors: parseInt(colorSlider.value, 10),
                    ltres: 1,
                    qtres: 1,
                    pathomit: 8
                };

                ImageTracer.imagedataToTracedata(imageData, (tracedata) => {
                    vectorizedData = tracedata;
                    console.log(`Vectorization complete with ${colorSlider.value} colors.`);
                    statusMessage.textContent = "Vectorization complete!";
                    saveButton.disabled = false; // Enable the save button
                }, options);
            }, 100);
        }

        /**
         * Assembles the final SVG string from tracedata.
         * This is Step 3.2.3 in the guide.
         */
        function assembleSvgString(data) {
            // Get dimensions from the tracedata
            const width = data.width;
            const height = data.height;

            // Start SVG string
            let svgString = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;

            // Iterate through each layer (color)
            data.layers.forEach((layer, layerIndex) => {
                // Get color from palette. Note: r,g,b values are 0-255
                const color = data.palette[layerIndex];
                const fillColor = `rgb(${color.r}, ${color.g}, ${color.b})`;

                // Create a group for the current color layer
                svgString += `<g fill="${fillColor}">`;

                // Append all paths for this layer
                layer.forEach(path => {
                    let pathString = '';
                    // Iterate through segments of the path
                    path.forEach(segment => {
                        // Move to the first point
                        pathString += `M ${segment[0][0]} ${segment[0][1]} `;
                        // Line to subsequent points
                        for (let i = 1; i < segment.length; i++) {
                            pathString += `L ${segment[i][0]} ${segment[i][1]} `;
                        }
                        // Close the path
                        pathString += 'Z ';
                    });
                    svgString += `<path d="${pathString}" />`;
                });
                
                // Close the group
                svgString += `</g>`;
            });

            // Close SVG string
            svgString += `</svg>`;
            return svgString;
        }

    </script>
</body>
</html>

